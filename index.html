<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ハイパー麻理子</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            font-family: 'Courier New', sans-serif;
            touch-action: none;
        }
        #gameCanvas {
            background-color: #87CEEB;
            border: 4px solid #fff;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            cursor: pointer;
            image-rendering: pixelated; /* ドット絵をくっきり表示 */
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 20px;
            text-shadow: 2px 2px 0 #000;
            text-align: center;
            pointer-events: none;
            z-index: 10;
        }
    </style>
</head>
<body>

<div id="ui">
    <div id="scoreBoard">STAGE: 1 | HP: 3</div>
    <div id="message">PRESS SPACE or CLICK TO START</div>
</div>
<canvas id="gameCanvas" width="800" height="600"></canvas>

<script>
// --- 麻理子ドット絵データ ---
// .:透明, R:赤, D:濃赤, S:肌色, B:青, H:茶色(髪/靴), Y:黄, W:白
const P = {
    _: null, 
    R: '#FF0000', D: '#8B0000', S: '#FFDAB9', 
    B: '#0000CD', H: '#482808', Y: '#FFD700', W: '#FFFFFF'
};

// 20x20ドットのデザインパターン
const SPRITES = {
    idle: [
        // 立ち
        "_______RRRRR________",
        "______RRRRRRR_______",
        "______RWWDRRR_______", // 帽子(Mマークイメージ)
        "_____HHHSSHHH_______", // 髪・顔
        "____H_S_SS_S_H______", // ツインテール・目
        "____H_SSSSSS_H______",
        "_______SSSS_________",
        "______RRRRRR________",
        "_____RRBBRR_________", // 体
        "____WRRBBRRW________", // 手
        "____WBBYYBBW________", // オーバーオール
        "____BBBBBBBB________",
        "____BB____BB________",
        "____HH____HH________", // 足
        "____HH____HH________"
    ],
    run1: [
        // 走り1
        "_______RRRRR________",
        "______RRRRRRR_______",
        "______RWWDRRR_______",
        "_____HHHSSHHH_______",
        "____H_S_SS_S_H______",
        "____H_SSSSSS_H______",
        "_______SSSS_________",
        "_______RRRR_________",
        "_____W_BBRR_W_______",
        "______RBBRRR________",
        "______BBYYBB________",
        "______BBBBBB________",
        "______BB__H_________",
        "_____HH___H_________",
        "__________H_________"
    ],
    run2: [
        // 走り2
        "_______RRRRR________",
        "______RRRRRRR_______",
        "______RWWDRRR_______",
        "_____HHHSSHHH_______",
        "____H_S_SS_S_H______",
        "____H_SSSSSS_H______",
        "_______SSSS_________",
        "_______RRRR_________",
        "_____W_BBRR_W_______",
        "_______RRRBBR_______",
        "______BBYYBB________",
        "______BBBBBB________",
        "_______H__BB________",
        "_______H___HH_______",
        "_______H____________"
    ],
    jump: [
        // ジャンプ(バンザイ)
        "_______RRRRR________",
        "______RRRRRRR_______",
        "______RWWDRRR_______",
        "_____HHHSSHHH_______",
        "____H_S_SS_S_H______",
        "____H_SSSSSS_H______",
        "_______SSSS_________",
        "____W__RRRR__W______", // 手を上げる
        "____R__BBRR__R______",
        "____R_BBYYBB_R______",
        "______BBBBBB________",
        "______BB__BB________",
        "_____H______H_______", // 足を開く
        "____H________H______",
        "____________________"
    ]
};

// --- ゲーム設定 ---
const CANVAS_WIDTH = 800;
const CANVAS_HEIGHT = 600;
const GRAVITY = 0.6;
const FRICTION = 0.8;
const JUMP_FORCE = 14;

const COLORS = {
    ground: '#8B4513',
    enemy:  '#800080',
    boss:   '#000000',
    goal:   '#FFD700'
};

const STAGE_CONFIG = {
    totalStages: 10,
    bossStages: [3, 5, 7, 10]
};

// --- ゲームクラス ---
class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.stage = 1;
        this.player = null;
        this.platforms = [];
        this.enemies = [];
        this.particles = [];
        this.boss = null;
        this.keys = {};
        this.cameraX = 0;
        this.gameState = 'START'; 
        this.uiMessage = document.getElementById('message');
        this.uiScore = document.getElementById('scoreBoard');
        
        this.initInput();
        this.loop = this.loop.bind(this);
        requestAnimationFrame(this.loop);
    }

    initInput() {
        window.addEventListener('keydown', e => {
            if(["Space","ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].indexOf(e.code) > -1) {
                e.preventDefault();
            }
            this.keys[e.code] = true;
            if ((e.code === 'Space' || e.code === 'ArrowUp') && 
                (this.gameState === 'START' || this.gameState === 'GAMEOVER' || this.gameState === 'VICTORY')) {
                this.handleStart();
            }
        });
        
        window.addEventListener('keyup', e => this.keys[e.code] = false);

        this.canvas.addEventListener('mousedown', () => {
            this.keys['Space'] = true;
            if (this.gameState === 'START' || this.gameState === 'GAMEOVER' || this.gameState === 'VICTORY') {
                this.handleStart();
            }
        });
        this.canvas.addEventListener('mouseup', () => this.keys['Space'] = false);
        this.canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.keys['Space'] = true;
            if (this.gameState === 'START' || this.gameState === 'GAMEOVER' || this.gameState === 'VICTORY') {
                this.handleStart();
            }
        }, {passive: false});
        this.canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            this.keys['Space'] = false;
        });
    }

    handleStart() {
        if (this.gameState === 'VICTORY' || this.gameState === 'GAMEOVER') {
            this.stage = 1;
        }
        this.resetStage();
    }

    resetStage() {
        this.player = new Player(100, 300);
        this.platforms = [];
        this.enemies = [];
        this.particles = [];
        this.boss = null;
        this.cameraX = 0;
        this.generateLevel(this.stage);
        this.gameState = 'PLAYING';
        this.updateUI();
    }

    generateLevel(stageNum) {
        let length = 2000 + (stageNum * 300);
        if (STAGE_CONFIG.bossStages.includes(stageNum)) length = 1200;

        // 地面
        for (let x = 0; x < length; x += 50) {
            if (!STAGE_CONFIG.bossStages.includes(stageNum) && x > 300 && x < length - 300) {
                if (Math.random() < (stageNum * 0.02)) continue; 
            }
            this.platforms.push(new Platform(x, CANVAS_HEIGHT - 50, 50, 50));
        }
        this.platforms.push(new Platform(-50, 0, 50, CANVAS_HEIGHT * 2));
        this.platforms.push(new Platform(length, 0, 50, CANVAS_HEIGHT * 2));

        if (!STAGE_CONFIG.bossStages.includes(stageNum)) {
            for (let x = 400; x < length - 400; x += 150 + Math.random() * 100) {
                let h = 150 + Math.random() * 200;
                this.platforms.push(new Platform(x, CANVAS_HEIGHT - h, 100, 20));
                if (Math.random() < 0.5 + (stageNum * 0.05)) {
                    this.enemies.push(new Enemy(x + 20, CANVAS_HEIGHT - h - 40));
                }
            }
            for (let x = 500; x < length - 300; x += 300) {
                if (Math.random() < 0.3 + (stageNum * 0.05)) {
                    this.enemies.push(new Enemy(x, CANVAS_HEIGHT - 90));
                }
            }
            this.goalX = length - 100;
        } else {
            const isBigBoss = stageNum === 10;
            this.boss = new Boss(length - 300, CANVAS_HEIGHT - (isBigBoss ? 250 : 150), isBigBoss);
            this.goalX = null;
        }
    }

    update() {
        if (this.gameState !== 'PLAYING') return;

        this.player.update(this.keys, this.platforms);

        if (this.player.y > CANVAS_HEIGHT) this.player.takeDamage(999);

        let targetCamX = this.player.x - CANVAS_WIDTH / 3;
        if (targetCamX < 0) targetCamX = 0;
        if (targetCamX > this.cameraX) this.cameraX = targetCamX;

        this.enemies.forEach(enemy => {
            enemy.update(this.platforms);
            if (enemy.isAlive && this.checkCollision(this.player, enemy)) {
                if (this.player.vy > 0 && this.player.y + this.player.height < enemy.y + enemy.height / 2) {
                    enemy.die();
                    this.player.vy = -8;
                    this.spawnParticles(enemy.x, enemy.y, COLORS.enemy);
                } else {
                    this.player.takeDamage(1);
                }
            }
        });

        if (this.boss) {
            this.boss.update(this.platforms, this.player);
            if (this.boss.isAlive && this.checkCollision(this.player, this.boss)) {
                 if (this.player.vy > 0 && this.player.y + this.player.height < this.boss.y + this.boss.height * 0.8) {
                    this.boss.takeDamage(1);
                    this.player.vy = -10;
                    this.spawnParticles(this.player.x, this.player.y + 40, '#FFF');
                } else {
                    this.player.takeDamage(1);
                }
            }
            if (!this.boss.isAlive && this.goalX === null) {
                this.goalX = this.boss.x + 200;
                this.spawnParticles(this.boss.x, this.boss.y, COLORS.boss, 50);
                this.boss = null;
            }
        }

        this.particles = this.particles.filter(p => p.life > 0);
        this.particles.forEach(p => p.update());

        if (this.goalX && this.player.x > this.goalX) this.nextStage();

        if (this.player.hp <= 0) {
            this.gameState = 'GAMEOVER';
            this.uiMessage.innerHTML = "GAME OVER<br>PRESS SPACE or CLICK";
            this.uiMessage.style.display = 'block';
        }
        this.updateUI();
    }

    draw() {
        this.ctx.fillStyle = '#87CEEB';
        this.ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        this.ctx.save();
        this.ctx.translate(-this.cameraX, 0);

        // 床
        this.platforms.forEach(p => {
            this.ctx.fillStyle = COLORS.ground;
            this.ctx.fillRect(p.x, p.y, p.width, p.height);
            this.ctx.fillStyle = '#228B22';
            this.ctx.fillRect(p.x, p.y, p.width, 10);
        });

        // ゴール
        if (this.goalX) {
            this.ctx.fillStyle = COLORS.goal;
            this.ctx.fillRect(this.goalX, CANVAS_HEIGHT - 250, 20, 200);
            this.ctx.fillStyle = 'red';
            this.ctx.beginPath();
            this.ctx.moveTo(this.goalX + 20, CANVAS_HEIGHT - 250);
            this.ctx.lineTo(this.goalX + 60, CANVAS_HEIGHT - 230);
            this.ctx.lineTo(this.goalX + 20, CANVAS_HEIGHT - 210);
            this.ctx.fill();
        }

        // 敵
        this.enemies.forEach(e => {
            if(e.isAlive) {
                this.ctx.fillStyle = COLORS.enemy;
                this.ctx.fillRect(e.x, e.y, e.width, e.height);
                this.ctx.fillStyle = 'white';
                this.ctx.fillRect(e.x + 5, e.y + 5, 10, 10);
                this.ctx.fillRect(e.x + 25, e.y + 5, 10, 10);
            }
        });

        // ボス
        if (this.boss && this.boss.isAlive) {
            this.ctx.fillStyle = COLORS.boss;
            this.ctx.fillRect(this.boss.x, this.boss.y, this.boss.width, this.boss.height);
            this.ctx.fillStyle = 'red';
            this.ctx.fillRect(this.boss.x, this.boss.y - 20, this.boss.width, 10);
            this.ctx.fillStyle = 'green';
            this.ctx.fillRect(this.boss.x, this.boss.y - 20, this.boss.width * (this.boss.hp / this.boss.maxHp), 10);
        }

        // プレイヤー（ドット絵描画）
        if (this.player && this.player.hp > 0) {
            this.player.draw(this.ctx);
        }

        // エフェクト
        this.particles.forEach(p => {
            this.ctx.fillStyle = p.color;
            this.ctx.fillRect(p.x, p.y, p.size, p.size);
        });

        this.ctx.restore();

        if (this.gameState === 'START') {
            this.uiMessage.style.display = 'block';
            this.uiMessage.innerHTML = "HYPER MARICO<br><br>PRESS SPACE or CLICK TO START";
        } else if (this.gameState === 'PLAYING') {
            this.uiMessage.style.display = 'none';
        }
    }

    loop() {
        this.update();
        this.draw();
        requestAnimationFrame(this.loop);
    }

    checkCollision(rect1, rect2) {
        return (rect1.x < rect2.x + rect2.width &&
                rect1.x + rect1.width > rect2.x &&
                rect1.y < rect2.y + rect2.height &&
                rect1.y + rect1.height > rect2.y);
    }

    spawnParticles(x, y, color, count = 10) {
        for (let i = 0; i < count; i++) this.particles.push(new Particle(x, y, color));
    }

    nextStage() {
        this.stage++;
        if (this.stage > STAGE_CONFIG.totalStages) {
            this.gameState = 'VICTORY';
            this.uiMessage.innerHTML = "ALL CLEAR!<br>YOU ARE A LEGEND!<br>PRESS SPACE or CLICK";
            this.uiMessage.style.display = 'block';
        } else {
            this.resetStage();
        }
    }

    updateUI() {
        this.uiScore.innerHTML = `STAGE: ${this.stage} / ${STAGE_CONFIG.totalStages} | HP: ${this.player ? this.player.hp : 0}`;
    }
}

// --- プレイヤークラス（ドット絵＆アニメーション対応） ---
class Player {
    constructor(x, y) {
        this.x = x; this.y = y; 
        this.width = 40; this.height = 40;
        this.vx = 0; this.vy = 0; 
        this.hp = 3; 
        this.onGround = false; 
        this.invincible = 0;
        
        // アニメーション用
        this.facingRight = true;
        this.animTimer = 0;
        this.animFrame = 0;
        this.state = 'idle'; // idle, run, jump
    }

    update(keys, platforms) {
        // 移動と向き
        let moving = false;
        if (keys['ArrowRight']) {
            this.vx += 1;
            this.facingRight = true;
            moving = true;
        }
        if (keys['ArrowLeft']) {
            this.vx -= 1;
            this.facingRight = false;
            moving = true;
        }
        
        this.vx *= FRICTION;
        this.x += this.vx;

        // 壁判定
        platforms.forEach(p => {
            if (this.checkCol(p) && this.y + this.height > p.y + 10) {
                if (this.vx > 0) this.x = p.x - this.width;
                else if (this.vx < 0) this.x = p.x + p.width;
                this.vx = 0;
            }
        });

        // ジャンプ
        if ((keys['Space'] || keys['ArrowUp']) && this.onGround) {
            this.vy = -JUMP_FORCE;
            this.onGround = false;
        }

        this.vy += GRAVITY;
        this.y += this.vy;

        // 接地判定
        this.onGround = false;
        platforms.forEach(p => {
            if (this.checkCol(p) && this.vy >= 0 && this.y + this.height - p.y < 20) {
                this.y = p.y - this.height;
                this.vy = 0;
                this.onGround = true;
            } else if (this.checkCol(p) && this.vy < 0) {
                this.y = p.y + p.height;
                this.vy = 0;
            }
        });

        if (this.invincible > 0) this.invincible--;

        // アニメーション状態更新
        if (!this.onGround) {
            this.state = 'jump';
        } else if (moving && Math.abs(this.vx) > 0.5) {
            this.state = 'run';
        } else {
            this.state = 'idle';
        }

        this.animTimer++;
        if (this.state === 'run') {
            if (this.animTimer > 5) { // 走る速度
                this.animFrame = (this.animFrame + 1) % 2;
                this.animTimer = 0;
            }
        } else {
            this.animFrame = 0;
        }
    }

    draw(ctx) {
        if (this.invincible > 0 && Math.floor(Date.now() / 50) % 2 === 0) return; // 点滅

        let spriteData = SPRITES.idle;
        if (this.state === 'jump') spriteData = SPRITES.jump;
        else if (this.state === 'run') spriteData = (this.animFrame === 0) ? SPRITES.run1 : SPRITES.run2;

        const pixelSize = 2.5; // ドットの大きさ

        ctx.save();
        // 中心を軸に反転させる処理
        if (!this.facingRight) {
            ctx.translate(this.x + this.width, this.y);
            ctx.scale(-1, 1);
            ctx.translate(0, 0); // 原点あわせ
        } else {
            ctx.translate(this.x, this.y);
        }

        // ドット絵の描画ループ
        for (let row = 0; row < spriteData.length; row++) {
            const line = spriteData[row];
            for (let col = 0; col < line.length; col++) {
                const colorCode = line[col];
                if (P[colorCode]) {
                    ctx.fillStyle = P[colorCode];
                    // 中央揃え調整
                    ctx.fillRect(col * pixelSize - 5, row * pixelSize - 5, pixelSize, pixelSize);
                }
            }
        }
        ctx.restore();
    }

    checkCol(p) {
        return (this.x < p.x + p.width && this.x + this.width > p.x &&
                this.y < p.y + p.height && this.y + this.height > p.y);
    }

    takeDamage(amount) {
        if (this.invincible > 0) return;
        this.hp -= amount;
        this.invincible = 60; 
        this.vy = -5;
        if (this.hp <= 0) this.hp = 0;
    }
}

class Enemy {
    constructor(x, y) {
        this.x = x; this.y = y; this.width = 40; this.height = 40;
        this.vx = -2; this.vy = 0; this.isAlive = true;
    }
    update(platforms) {
        if (!this.isAlive) return;
        this.vy += GRAVITY;
        this.x += this.vx;
        this.y += this.vy;
        let grounded = false;
        platforms.forEach(p => {
            if (this.x < p.x + p.width && this.x + this.width > p.x &&
                this.y < p.y + p.height && this.y + this.height > p.y) {
                if (this.vy >= 0 && this.y + this.height - p.y < 20) {
                    this.y = p.y - this.height;
                    this.vy = 0;
                    grounded = true;
                } else this.vx *= -1;
            }
        });
        if (grounded && Math.random() < 0.01) this.vx *= -1;
    }
    die() { this.isAlive = false; }
}

class Boss {
    constructor(x, y, isBig) {
        this.x = x; this.y = y;
        this.width = isBig ? 120 : 80; this.height = isBig ? 120 : 80;
        this.hp = isBig ? 10 : 3; this.maxHp = this.hp;
        this.isBig = isBig;
        this.vx = -3; this.vy = 0; this.isAlive = true; this.jumpTimer = 0;
    }
    update(platforms, player) {
        if (!this.isAlive) return;
        this.vy += GRAVITY;
        this.x += this.vx;
        this.y += this.vy;
        platforms.forEach(p => {
            if (this.x < p.x + p.width && this.x + this.width > p.x &&
                this.y < p.y + p.height && this.y + this.height > p.y) {
                if (this.vy >= 0) { this.y = p.y - this.height; this.vy = 0; }
            }
        });
        this.jumpTimer++;
        if (this.jumpTimer > 100) {
            this.vy = -12;
            this.vx = (player.x < this.x) ? -5 : 5;
            this.jumpTimer = 0;
        }
        if (this.x < player.x - 400 || this.x > player.x + 400) this.vx *= -1;
    }
    takeDamage(amount) { this.hp -= amount; if (this.hp <= 0) this.isAlive = false; }
}

class Platform { constructor(x, y, w, h) { this.x = x; this.y = y; this.width = w; this.height = h; } }
class Particle {
    constructor(x, y, color) {
        this.x = x; this.y = y;
        this.vx = (Math.random() - 0.5) * 10;
        this.vy = (Math.random() - 0.5) * 10;
        this.life = 30;
        this.color = color;
        this.size = Math.random() * 5 + 2;
    }
    update() { this.x += this.vx; this.y += this.vy; this.life--; }
}

window.onload = () => { new Game(); };
</script>
</body>
</html>
